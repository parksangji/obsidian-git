동시성 제어는 여러 트랜잭션이 동시에 동일한 데이터에 접근하여 조작할 때 발생할 수 있는 문제를 방지하고 데이터의 무결성을 유지하기 위한 데이터베이스 시스템의 메커니즘이다. 이는 [[트랜잭션 격리 수준(Transaction Isolation Level)]] 과 밀접하게 관련되어 있으며, 격리 수준을 구현하는 구체적인 방법 중 하나가 잠금(Locking)이다. 

동시정 제어가 필요한 이유:
- Lost Update (갱신 손실): 두 트랜잭셔닝 동일한 데이터를 동시에 수정하여 하나의 수정이 무시되는 문제.
- Dirty Read (더티 리드): 한 트랜잭션이 아직 커밋되지 않는 데이터를 다른 트랜잭션이 읽는 문제.
- Non-Repeatable Read: 한 트랜잭션 내에서 동일한 데이터를 두 번 읽었을 때 결과가 다른 문제 (중간에 다른 트랜잭션이 데이터를 삽입)
- Phantom Read (유령 읽기): 한 트랜잭션 내에서 동일한 범위의 데이터를 두 번 읽었을 때 결과가 다른 문제 (중간에 다른 트랜잭션이 데이터를 삽입)


1. 비관적 잠금 (Pessimistic Locking)
	개념: "동시에 접근하면 충돌이 발생할 가능성이 높다"고 가정하고, 데이터에 접근ㄴ하기 전에 미리 잠금을 걸어 다른 트랜잭션의 접근을 막는 방식이다. 잠금은 트랜잭션이 완료될 때까지 유지된다. 
	
	동작방식:
	1. 데이터를 읽거나 수정하기 전에 해당 데이터에 잠금을 요청
	2. 다른 트랜잭션이 이미 해당 데이터에 잠금을 걸고 있다면, 잠금이 해제될 때까지 대기 
	3. 잠금을 획득하면 데이터를 읽거나 수정하고, 트랜잭션이 완료되면 잠금을 해제 
	
	종류:
	- 공유 잠금 (shared Lock, Read Loca) 여러 트랜잭션이 동시에 데이터를 읽는 것은 허용하지만, 수정은 막는다. 
	- 베타적 잠금 (Exclusive Lock/ Write Lock): 오직 하나의 트랜잭션만이 데이터를 읽고 쓸 수 있도록 한다. 다른 트랜잭션(읽기 포함)의 접근을 모두 막는다. 
	
	장점:
	- 데이터 충돌을 확실하게 방지하여 데이터 무결성을 보장한다. 
	- 로직이 비교적 단순하다. 
	
	단점:
	- 잠금으로 인해 다른 트랜잭션이 대기해야 하므로 동시성이 저하된다. 
	- 잠금을 오래 유지하면 시스템 전체 성능에 병목이 될 수 있다. 
	- 잠금 순서가 잘못되면 교착 상태(Deadlocak)가 발생할 가능성이 있다. 
	사용시기: 데이터 충돌이 빈번하게 발생할 것으로 예상되는 환경, 데이터 정합성이 매우 중요한 경우 

```sql
-- 트랜잭션 시작
BEGIN;

-- products 테이블에서 id=1 인 행에 배타적 잠금 획득
SELECT * FROM products WHERE id = 1 FOR UPDATE;

-- 데이터 수정 (잠금을 획득했으므로 안전하게 수정 가능)
UPDATE products SET stock = stock - 1 WHERE id = 1;

-- 트랜잭션 종료 (잠금 해제)
COMMIT;
```


2. 낙관적 잠금(Optimistic Locking)
	개념: "동시에 접근해도 충돌이 발생할 가능성은 낮다"고 가정하고, 일단 잠금 없이 데이터를 읽는다. 그리고 데이터를 수정하고 커밋하는 시점에 다른 트랜잭션에 의해 데이터가 변경되지 않았는지 검사하여 충돌 여부를 확인하는 방법이다. 
	동작 방식 (일반적인 버전 관리 방식):
	- 데이터를 읽을 때 데이터 값과 함계 버전 정보를 함께 읽는다. 
	- 데이터를 수정하고 커밋하기 전에, 현재 데이터베이스에 저장된 버전 정보가 처음에 읽었던 버전 정보와 동일한지 확인한다. 
	- 버전이 동일: 다른 트랜잭션에 의해 변경되지 않았으므로, 데이터를 수정하고 버전 정보를 증가시킨다. 
	- 버전이 다름: 다른 트랜잭션이 중간에 데이터를 수정했다는 의미이므로, 현재 트랜잭션의 수정을 거부한다. 
	
	구현:
	- 테이블에 version 컬럼을 추가한다. 
	- update 문에서 where 절에 읽었던 버전 정보를 포함시켜 조건부 업데이트를 수행한다. 
	
	장점:
	- 데이터를 읽을 때 잠금을 사용하지 않으므로 동시성이 높다.
	- 잠금 오버헤드가 적고 교착 상태 발생 가능성이 낮다.
	단점:
	- 커밋 시점에 충돌을 감지하므로, 충돌이 발생하면 이미 수행한 작업이 헛수고가 될 수 있다. 
	- 충돌이 빈번하게 발생하면 롤백 및 재시도 비용으로 인해 오히려 성능이 저하될 수 있다. 
	- 애플리케이션 레벨에서 재시도 로직 등을 구현해야 할 수 있다. 
```sql 
-- 1. 데이터 읽기 (version 정보 포함)
-- 애플리케이션 코드에서 읽은 version 값을 기억 (예: current_version = 5)
SELECT name, price, version FROM products WHERE id = 1;

-- 2. 데이터 수정 및 커밋 시도
-- UPDATE 문에서 WHERE 절에 읽었던 version을 조건으로 추가
UPDATE products
SET price = 1100, version = version + 1 -- 버전 증가
WHERE id = 1 AND version = 5; -- 처음에 읽었던 버전(5)과 같은지 확인

-- 만약 UPDATE 결과, 수정된 행(row)의 수가 0이면
-- 다른 트랜잭션이 중간에 수정했다는 의미 -> 롤백 후 재시도
-- 수정된 행의 수가 1이면 -> 성공적으로 수정됨 -> 커밋
```

```java
// JPA(Java Persistence API)에서는 낙관적 잠금을 쉽게 사용할 수 있도록 지원합니다.
@Entity
public class Product {
    @Id
    private Long id;
    private String name;
    private Integer price;

    @Version // 버전 관리를 위한 어노테이션
    private Long version;

    // getters and setters
}

// ... 서비스 코드 ...
// Product product = entityManager.find(Product.class, 1L); // version 포함하여 조회
// product.setPrice(1100);
// entityManager.merge(product); // 커밋 시점에 JPA가 자동으로 version 비교 및 증가 처리
```

| 특징           | 비관적 잠금 (Pessimistic) | 낙관적 잠금 (Optimistic) |
| :----------- | :------------------- | :------------------ |
| **가정**       | 충돌 가능성 높음            | 충돌 가능성 낮음           |
| **잠금 시점**    | 데이터 접근 전             | 커밋 시점 (버전 체크)       |
| **동시성**      | 낮음                   | 높음                  |
| **교착 상태 위험** | 높음                   | 낮음 (충돌 시 재시도)       |
| **오버헤드**     | 잠금 관리 오버헤드           | 버전 관리/재시도 오버헤드      |
| **적합 환경**    | 충돌 빈번, 정합성 중요        | 충돌 드묾, 읽기 위주        |