---
title: REST (Representational State Transfer)
category: Network
description: 웹 서비스 API 설계를 위한 아키텍처 스타일과 제약 조건
image: "/assets/images/\brest.png"
---

# REST (Representational State Transfer)

## REST란 무엇인가?

REST는 분산 하이퍼미디어 시스템(예: 월드 와이드 웹)을 위한 **아키텍처 스타일(Architectural Style)**입니다. 특정 프로토콜이나 표준이 아니라, 웹의 장점을 최대한 활용할 수 있는 아키텍처를 설계하기 위한 일련의 **제약 조건(Constraints)**들의 집합입니다. Roy Fielding의 박사 논문에서 처음 소개되었으며, 웹의 기본 원칙을 기반으로 합니다.

REST의 핵심 아이디어는 **자원(Resource)**을 정의하고, **자원의 표현(Representation)**을 통해 해당 자원의 상태를 주고받는 것입니다. 모든 자원은 고유한 식별자(URI)를 가지며, 클라이언트는 HTTP 메서드(GET, POST, PUT, DELETE 등)를 사용하여 자원에 대한 원하는 작업을 요청합니다.

## REST의 핵심 제약 조건

REST 아키텍처 스타일을 따른다고 말하려면 다음 제약 조건들을 만족해야 합니다.

### 1. 클라이언트-서버 (Client-Server) 구조

* **관심사 분리:** 클라이언트(사용자 인터페이스 담당)와 서버(자원 저장 및 관리, 비즈니스 로직 담당)의 역할이 명확하게 분리됩니다.
* **장점:**
    * 서버는 클라이언트에 독립적으로 발전할 수 있습니다 (예: 여러 플랫폼의 클라이언트 지원 용이).
    * 클라이언트는 서버 구현 세부 사항에 대해 알 필요가 없습니다.
    * 각각의 개발 및 확장이 용이해집니다.

### 2. 무상태성 (Statelessness)

* **서버의 상태 비저장:** 서버는 클라이언트의 상태(세션, 컨텍스트 등)를 요청 간에 저장하지 않습니다.
* **요청의 독립성:** 각 요청은 서버가 해당 요청을 이해하고 처리하는 데 필요한 모든 정보를 포함해야 합니다. (필요한 경우, 클라이언트가 상태 정보를 요청에 담아 보냄)
* **장점:**
    * **가시성(Visibility):** 요청만 보고도 내용을 파악하기 쉽습니다.
    * **신뢰성(Reliability):** 특정 요청 실패가 다른 요청에 영향을 주지 않습니다.
    * **확장성(Scalability):** 서버는 클라이언트 상태를 저장할 필요가 없으므로, 요청을 어떤 서버 인스턴스에서든 처리할 수 있어 로드 밸런싱 및 확장이 용이합니다.

### 3. 캐시 가능성 (Cacheability)

* **응답 캐싱:** 클라이언트는 서버 응답을 캐싱할 수 있어야 합니다. 서버 응답은 명시적 또는 암묵적으로 캐시 가능한지 여부를 표시해야 합니다.
* **HTTP 캐싱 활용:** HTTP의 `Cache-Control`, `ETag`, `Last-Modified` 등의 헤더를 사용하여 캐시를 제어합니다.
* **장점:**
    * 클라이언트-서버 간 상호작용을 줄여 성능과 효율성을 향상시킵니다.
    * 서버 부하를 줄여 확장성을 개선합니다.

### 4. 계층형 시스템 (Layered System)

* **중간 계층 허용:** 클라이언트는 자신이 직접 최종 서버와 통신하는지, 아니면 중간의 프록시, 게이트웨이, 로드 밸런서 등과 통신하는지 알 수 없습니다.
* **장점:**
    * 각 계층은 특정 기능(로드 밸런싱, 보안, 캐싱 등)에 집중할 수 있습니다.
    * 시스템 확장성 및 보안을 향상시킵니다.
    * 구현 단순화: 각 구성 요소는 인접한 계층하고만 상호작용하면 됩니다.

### 5. 인터페이스 일관성 (Uniform Interface)

* **아키텍처 단순화 및 분리:** 클라이언트와 서버 간의 상호작용 방식을 표준화하여 전체 시스템 아키텍처를 단순화하고 각 부분의 독립적인 진화를 가능하게 합니다.
* **네 가지 하위 제약 조건:**
    1.  **자원의 식별 (Identification of resources):** 자원은 URI(Uniform Resource Identifier)를 통해 고유하게 식별되어야 합니다. (예: `/users/123`)
    2.  **표현을 통한 자원 조작 (Manipulation of resources through representations):** 클라이언트는 자원의 상태를 직접 조작하는 것이 아니라, 자원의 표현(예: JSON, XML 형식의 데이터)을 주고받으며 상호작용합니다. 서버는 요청된 작업을 수행하고 적절한 표현과 상태 코드로 응답합니다.
    3.  **자기 서술적 메시지 (Self-descriptive messages):** 각 메시지(요청/응답)는 그 자체로 메시지를 어떻게 처리해야 하는지에 대한 충분한 정보(메타데이터)를 포함해야 합니다. (예: 어떤 HTTP 메서드를 사용하는지, 어떤 미디어 타입(`Content-Type`)인지 등)
    4.  **애플리케이션 상태 엔진으로서의 하이퍼미디어 (Hypermedia As The Engine Of Application State - HATEOAS):** (가장 중요한 동시에 가장 구현하기 어려운 제약) 클라이언트가 특정 자원에 접근하면, 서버는 응답에 해당 자원과 관련된 다음 가능한 동작(액션)들에 대한 하이퍼미디어 링크를 함께 제공해야 합니다. 클라이언트는 이 링크들을 통해 애플리케이션 상태를 전이시키며 상호작용합니다. 이를 통해 클라이언트는 API의 구조를 미리 알 필요 없이 동적으로 상호작용할 수 있습니다.

### 6. 코드 온 디맨드 (Code-On-Demand - Optional)

* **선택적 제약 조건:** 서버가 클라이언트로 실행 가능한 코드(예: JavaScript)를 전송하여 클라이언트의 기능을 일시적으로 확장하거나 커스터마이징할 수 있습니다. 웹 브라우저에서 JavaScript를 사용하는 것이 대표적인 예입니다.

## RESTful API

위의 REST 제약 조건을 준수하여 설계된 API를 "RESTful API"라고 부릅니다. 일반적으로 다음과 같은 특징을 가집니다.

* 자원(명사)은 URI로 표현됩니다.
* 자원에 대한 행위(동사)는 HTTP 메서드(GET, POST, PUT, PATCH, DELETE 등)로 표현됩니다.
* 자원의 상태는 JSON 또는 XML과 같은 형식의 표현(Representation)으로 전달됩니다.

**예시:**

* `GET /users`: 모든 사용자 목록 조회
* `GET /users/123`: ID가 123인 사용자 정보 조회
* `POST /users`: 새로운 사용자 생성 (요청 본문에 사용자 정보 포함)
* `PUT /users/123`: ID가 123인 사용자 정보 전체 수정 (요청 본문에 전체 정보 포함)
* `PATCH /users/123`: ID가 123인 사용자 정보 일부 수정 (요청 본문에 변경할 정보만 포함)
* `DELETE /users/123`: ID가 123인 사용자 삭제

## REST의 이점

* **확장성 (Scalability):** 무상태성, 계층형 시스템, 캐싱 등의 특징으로 인해 대규모 시스템으로 확장하기 용이합니다.
* **단순성 (Simplicity):** 인터페이스 일관성을 통해 시스템 구조와 상호작용 방식을 단순화합니다.
* **이식성 (Portability):** 클라이언트-서버 분리로 인해 클라이언트와 서버가 다른 기술 스택을 사용해도 괜찮습니다.
* **신뢰성 (Reliability):** 무상태성으로 인해 특정 요청의 실패가 다른 요청에 영향을 미치지 않습니다.
* **수정 용이성 (Modifiability):** 각 컴포넌트가 분리되어 있어 수정 및 개선이 용이합니다.
* **성능 (Performance):** 캐싱을 통해 성능을 향상시킬 수 있습니다.

## 백엔드 개발자와의 관련성

* **API 설계 표준:** 현대 웹 서비스 및 마이크로서비스 환경에서 API를 설계하는 사실상의 표준 방식으로 사용됩니다.
* **프레임워크 지원:** Spring Boot (Spring Web MVC/WebFlux)와 같은 대부분의 백엔드 프레임워크는 RESTful API 개발을 위한 강력한 기능을 제공합니다 (`@RestController`, `@GetMapping`, `@PostMapping` 등).
* **유지보수 및 협업:** 잘 설계된 RESTful API는 이해하기 쉽고 예측 가능하여 유지보수 및 다른 개발자와의 협업을 용이하게 합니다.
* **성능 및 확장성:** REST 원칙을 잘 따르면 자연스럽게 확장 가능하고 성능 좋은 시스템을 구축하는 데 도움이 됩니다.

REST 원칙을 이해하고 이를 API 설계에 적용하는 것은 현대적인 백엔드 개발자에게 필수적인 역량입니다.

다음 학습을 원하시면 "다음"을 입력해주세요.